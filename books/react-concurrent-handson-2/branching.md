---
title: "裏の世界を見てみよう"
---

# 世界の分岐を体験する

では満を辞して、この本のタイトルにもなっている「世界の分岐」を体験してみます。

さっそく、`App`を1行だけ書き換えてみましょう。書き換えるのは前章で伏線と言ってあった`setCounter`のところです。

```diff tsx
 function App() {
   const [counter, setCounter] = useState(0);
   return (
     <div className="text-center">
       <h1 className="text-2xl">React App!</h1>
       <Suspense fallback={<p>Loading...</p>}>
         <ShowData dataKey={counter} />
       </Suspense>
       <p>
         <button
           className="border p-1"
           onClick={() => {
             startTransition(() => {
-              setCounter(counter + 1);
+              setCounter((c) => c + 1);
             });
           }}
         >
           Counter is {counter}
         </button>
       </p>
     </div>
   );
 }
```

こうすると、ボタンを1回押したときの挙動は変わりませんが、ボタンを連打したときの挙動が変わります。例えば、「Counter is 0」の状態から10回ボタンを押した場合、次に画面が更新されたときはいきなり「Counter is 10」になります。レンダリングの一貫性のため、`ShowData`に表示されるのももちろん「Data for 10 is …」です。さらに、ボタンを押し続けた場合ずっと画面が更新されず、最後にボタンを押してから1秒経ってやっとサスペンドが終了するという挙動になります。

この挙動が意味することは、画面にはずっと`counter`が0の世界を表示し続けているにもかかわらず、裏では`counter`が1→2→3→……と変化している世界が存在しているということです。画面にレンダリングはされないが存在している、まさに“裏の世界”ですね。

裏の世界が表に出てくる（裏の世界のレンダリング結果が反映される）のは、裏の世界のレンダリングが完了した（＝サスペンドが終了した）ときです。今回ボタンを押し続けているといつまでのサスペンドが終了しなかったのは、ボタンを押すたびに裏の世界のステートが更新され、それに伴って再レンダリングが起こり、新たに1秒待たなければいけなくなるからです。

次の図は、このサンプルで起こっていることを表したものです（10回は多いのでボタンを2回押した場合の例です）。

![表の世界と裏の世界の状態の模式図](/images/react-concurrent-handson-2/branching-1.png)

最初の状態では counter=0 であり、これは画面に表示されている状態、すなわち表の世界の状態です。ボタンを押して`setCounter`が実行されたことにより counter=1 になりますが、今回その結果としてサスペンドが発生し、しかも`setCounter`はトランジションだったので、 counter=1 は裏の世界の状態となり、表の世界は counter=0 の状態が維持されます。

counter=1 の世界に対するサスペンドが完了する前に再び`setCounter`を実行した場合、それが裏の世界に適用されます（今回は引数が`(c) => c + 1`だったので、この関数が裏の世界の状態に適用されて counter=2 となります）。ステートが更新されたことで、counter=2 のレンダリングが開始されます（再びサスペンドします）。

今度は counter=2 の世界でのレンダリングが無事に完了（サスペンドが完了）したので、それが画面が反映されます。つまり、この時点で counter=2 は表の世界になります。

ちなみに、前章のサンプル（`setCounter(counter + 1)`の場合）でも裏の世界は存在していました。しかし、2回目以降にボタンを押した際は裏の世界のステートが変わらない（同じ値が再びセットされる）ためサスペンドの中止と再レンダリングという挙動にならず、最初にボタンを押してから1秒後に表の世界に反映される挙動となっていたのです。

# レンダリングは何回試みられるのか

上の例で、counter=2 に対するレンダリングが何回試みられるのかお分かりでしょうか。一見すると、2回（counter=2 になった瞬間と、その1秒後にサスペンドが完了した後の再レンダリング）であるように思われます。しかし、実際には3回です。残りの1回はいつかというと、「counter=1 になった1秒後」です。分かりやすくするために先ほどは省略していましたが、レンダリングが試みられるタイミングを上の図に①〜③として書き入れると次のようになります。

![counter=2 でレンダリングが行われる3箇所を記入した模式図](/images/react-concurrent-handson-2/branching-2.png)

ここで起こっていることを時系列順に書くと次のようになります。

1. `setCounter`によって counter=1 になり、 counter=1 でレンダリングされた結果サスペンドする（レンダリングⒶ）。
2. `setCounter`によって counter=2 になり、レンダリング①が行われ、サスペンドする。
3. 1の1秒後にサスペンドが終了し、再レンダリングが行われる。このときすでに裏の世界は counter=2 になっているので、 counter=2 でレンダリングされる（レンダリング②）。2からまだ1秒経っておらずデータが無いので、再びサスペンドする。
4. 2の1秒後にサスペンドが終了し、再レンダリングが行われる（レンダリング③）。今回はサスペンドしないので表の世界に counter=2 が反映される。
5. 3の1秒後にサスペンドが終了するが、すでに counter=2 のレンダリング結果は表の世界に反映されているので再レンダリングはされない（図中の×）。

ポイントは、counter=1 のときに行われたレンダリングⒶのサスペンドが完了する前にステートが更新されて counter=2 になったものの、Ⓐのサスペンド完了時の再レンダリングは中止されずに行われるということです。ただし、その際は（裏の世界の）最新のステートで再レンダリングが行われるため、counter=2 での再レンダリングとなります（レンダリング②）。

その後行われるレンダリング③でレンダリングが成功した（サスペンドしなかった）ため counter=2 のレンダリングが完了したとみなされます。一応②の1秒後にもサスペンド完了による再レンダリングが予定されていましたが、すでに表の世界に反映されたステートに対しては再度再レンダリングを試みることはありません。これが図中の×です。

あまり無いことですが、もし②の時点でレンダリングに成功した（サスペンドしなかった）場合、それが表の世界に反映されます。その場合は③のレンダリングは発生しません。

以上のことは例えば`ShowData`コンポーネントに`console.log`を仕込んでみることで確かめることができます。

このように、サスペンドの機構を活用する場合、表の世界に反映されないレンダリングというのも裏で複数回行われています。上の図はボタンを2回押した場合の例でしたが、ボタンを10連打した場合は counter=10 でのレンダリングは裏で10回以上行われるでしょう。それは何だか無駄が多い気もしますが、そもそもトランジションは優先度が低い更新だったので多少無駄があって画面への反映が遅れても問題はないのです。良くできていますね。
